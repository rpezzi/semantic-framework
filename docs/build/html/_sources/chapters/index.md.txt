# Welcome to Semantiva

**Semantiva** is an open-source framework that brings **Domain-Driven Design**, **Type-Oriented Development**, and **semantic transparency** together under one roof. By pairing each data type with matching algorithm definitions—and embedding domain concepts at every stage—Semantiva streamlines complex data pipelines into clear, scalable, and easily maintainable workflows.

**Why Semantiva?**  
- **Aligned with Real-World Needs**: Design your data structures and operations around actual domain entities, eliminating confusion and wasted effort.  
- **Type-Safe Workflows**: Prevent costly errors and ambiguities by ensuring each algorithm processes exactly the data it was built for.  
- **Semantic Transparency**: Make every transformation explainable, so that team members and stakeholders can trust your results, from quick prototypes to HPC-scale deployments.  
- **Future-Proof**: Scale seamlessly by adding new data types, integrating cloud or cluster resources, and leveraging modular pipelines that adapt to evolving requirements.

Explore our [Documentation](1.introduction) to see how Semantiva redefines data processing—connecting scientists, engineers, and software developers through a shared, semantically rich approach. Wherever clarity and reliability matter, Semantiva is here to help you build solutions that stand the test of time.


## Getting Started with Semantiva

This short guide helps you **jump right in** with a minimal example showcasing **Semantiva’s** modular design. We’ll create and process a simple **string literal** rather than dealing with more complex domains like audio or images.


```python
#########################
# Step 1: Define StringLiteralDataType
#########################
from semantiva.data_types import BaseDataType


class StringLiteralDataType(BaseDataType):
    """
    Represents a simple string literal data type.

    This class encapsulates a Python string, ensuring type consistency
    and providing a base for operations on string data.
    """

    def __init__(self, data: str):
        """
        Initialize the StringLiteralDataType with the provided string.

        Args:
            data (str): The string data to encapsulate.
        """
        super().__init__(data)

    def validate(self, data):
        """
        Validate that the provided data is a string literal.

        Args:
            data: The value to validate.
        """
        assert isinstance(data, str), "Data must be a string."


#########################
# Step 2: Create a Specialized StringLiteralAlgorithm Using AlgorithmTopologyFactory
#########################
from semantiva.data_operations import AlgorithmTopologyFactory

# Dynamically create a base algorithm class for (StringLiteralDataType -> StringLiteralDataType)
StringLiteralAlgorithm = AlgorithmTopologyFactory.create_algorithm(
    input_type=StringLiteralDataType,
    output_type=StringLiteralDataType,
    class_name="StringLiteralAlgorithm",
)


#########################
# Step 3: Define HelloOperation (Extending StringLiteralAlgorithm)
#########################
class HelloOperation(StringLiteralAlgorithm):
    """
    A simple operation that modifies the input string to greet the inout
    and returns the updated value as a new StringLiteralDataType.
    """

    def _operation(self, data: StringLiteralDataType) -> StringLiteralDataType:
        """
        Prepends "Hello, " to the input string and returns it as a new StringLiteralDataType.

        Args:
            data (StringLiteralDataType): The input data containing a Python string.

        Returns:
            StringLiteralDataType: The updated data containing the greeting.
        """
        hello_data = f"Hello, {data.data}"
        return StringLiteralDataType(hello_data)


#########################
# Step 4: Create a Pipeline Configuration Using HelloOperation
#########################
node_configurations = [
    {
        "operation": HelloOperation,
        "parameters": {},  # No extra parameters needed
        "context_operation": ContextPassthrough,
    },
]


#########################
# Step 5: Instantiate and Use the Pipeline
#########################
from semantiva.payload_operations import Pipeline

if __name__ == "__main__":
    # 1. Initialize the minimal pipeline with our node configurations
    pipeline = Pipeline(node_configurations)

    # 2. Create a StringLiteralDataType object
    input_data = StringLiteralDataType("World!")

    # 3. Run the pipeline
    output_data, _ = pipeline.process(input_data, {})

    # 4. Print final result
    print("Pipeline completed. Final output:", output_data.data)
```
